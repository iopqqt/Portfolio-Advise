# -*- coding: utf-8 -*-
"""串接API.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13dNDiq74C4clqym3sed33M_2D-as65NN
"""

# 安裝富果行情 API 套件
!pip install fugle-marketdata -U -q

# 安裝 linetool 套件
!pip install linetool -q

# 載入套件
from fugle_marketdata import WebSocketClient, RestClient
import pandas as pd
import numpy as np

# API Key 可至金鑰申請與管理頁的行情 API 區申請：https://developer.fugle.tw/docs/key/
client = RestClient(api_key = 'NTU3NjZjY2EtOTc1YS00NGM3LTkyOWUtZDUyMjIzNWYzNGU3IDhhNTcwZjljLWRhOTktNDRmYS04NDBhLTMxZGM4ZDJhNjY4Yg==')
stock = client.stock  # Stock REST API client

# 輸入股票代碼
user_input = input("輸入股票代碼(以空格分隔):")

# 分割字串
codelists = user_input.split()

# 取得個股最新交易日
newest_day = stock.intraday.ticker(symbol=codelists[0])['date']
start_day = pd.Timestamp(newest_day) - pd.Timedelta('365D')

# 建立空的DataFrame
all_stocks_data = pd.DataFrame()

for i in codelists:

    history_options = {
        "symbol": i,
        "from": start_day, #設定往回30天
        "to": newest_day,
        "timeframe": "D",
        "fields": "close"
    }

    stock_data = pd.DataFrame(stock.historical.candles(**history_options)['data']).sort_values(by='date')

    # 新增股票代碼欄位
    stock_data["code"] = i

    # 合併DataFrame
    all_stocks_data = pd.concat([all_stocks_data, stock_data])

print(all_stocks_data)

# 計算每一檔的報酬率
ret = all_stocks_data.groupby('code')['close'].pct_change()
#print(ret)
all_stocks_data['return'] = ret
#print(all_stocks_data)

all_stocks_data = all_stocks_data.dropna()
print(all_stocks_data)
select_data = all_stocks_data[['code','return']]
select_data = select_data.reset_index()
print(select_data)
print(select_data.columns)
# 轉成以code為欄位名稱
retData = select_data.pivot_table(index='index', columns='code', values='return')
retData = retData.dropna()

print(retData)

column_names = retData.columns
print(column_names)

cov_matrix=retData.cov()*252                   #共變異矩陣
print('共變異數矩陣:')
print(cov_matrix)

cor_matrix=retData.corr()                    #相關係數矩陣
print('相關係數矩陣:')
print(cor_matrix)

ann_returns=retData.mean()*252                  #年化報酬
print(retData.mean())
print('年化報酬:')
print(ann_returns)

def portfolio_performance(weights, ann_returns, cov_matrix):
    returns = np.sum(ann_returns*weights )
    std = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
    return std, returns

def random_portfolios(num_portfolios, ann_returns, cov_matrix):
    results = np.zeros((3,num_portfolios))
    weights_record = []
    for i in range(num_portfolios):
        weights = np.random.random(len(column_names))
        weights /= np.sum(weights)
        weights_record.append(weights)
        portfolio_std_dev, portfolio_return = portfolio_performance(weights, ann_returns, cov_matrix)
        results[0,i] = portfolio_std_dev
        results[1,i] = portfolio_return
        results[2,i] = (portfolio_return) / portfolio_std_dev #sharpe ratio
    return results, weights_record

num_portfolios = 50000
portfolios_result,portfolios_weights = random_portfolios(num_portfolios, ann_returns, cov_matrix)

print('年化報酬:')
print(ann_returns)
print('第一個權重:', portfolios_weights[0])         #全部有50000個權重投資組合 這是第1個
print('第一個權重的年化報酬率:', portfolios_result[1][0])  #這是第1個權重的報酬率
print('第一個權重的年化標準差:', portfolios_result[0][0])  #這是第1個權重的標準差
print(portfolios_weights[:10])
max_portfolios_result = max(portfolios_result[1,])
min_portfolios_result = min(portfolios_result[1,])
print('投組年化報酬最大值:',max_portfolios_result)
print('投組年化報酬最小值:',min_portfolios_result)

import matplotlib.pyplot as plt

print(portfolios_result[1,])
#plt.plot(portfolios_result[0,],portfolios_result[1,])

plt.scatter(portfolios_result[0,], portfolios_result[1,],c='royalblue',marker='o',alpha=0.7,s=1,label='Portfolio')
plt.xlabel('Annualized Std')
plt.ylabel('Annualized Return')
plt.grid(True, linestyle='--', alpha=0.5)

specific_return_value = 0.10
plt.axhline(y=specific_return_value, color='red', linestyle='--', linewidth=1, label='Expected Annualized Return')


plt.legend()
plt.show()

import numpy as np
import pandas as pd
from decimal import Decimal


while True:
    user_input = float(input("輸入目標年化報酬(數值介於{}-{}):".format(round(min_portfolios_result,4),round(max_portfolios_result,4))))

    #找輸入的小數點後有幾位數
    decimal_number = Decimal(str(user_input))
    decimal_number = abs(decimal_number.as_tuple().exponent)

    #把全部報酬round到decimal_number
    results_test = np.trunc(portfolios_result[1,] * 10**decimal_number) / (10**decimal_number)

    #然後找出報酬等於user_input的index
    indices_of_userinput = [index for index, value in enumerate(results_test) if value == user_input]

    #如果index是空的表示找不到對應的投組權重，所以重新輸入目標年化報酬
    if not indices_of_userinput:
        print("找不到符合條件的投組，請重新輸入目標年化報酬。")
        continue

    #再找出這些index裡面最小的標準差和回傳index
    df = pd.DataFrame(portfolios_result[0,][indices_of_userinput], index=indices_of_userinput)
    user_output_sd = min(df.iloc[:,0])
    user_output_index = df.index[df.iloc[:,0] == user_output_sd][0]

    #最後找出對應的權重
    print('該目標年化報酬下的投組權重(%):', portfolios_weights[user_output_index] * 100)
    print('該目標年化報酬下的投組年化標準差:', user_output_sd)
    break

#更改權重(微調) 計算、驗算標準差看會不會差太多